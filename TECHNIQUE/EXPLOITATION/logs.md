# Logs

## Généralités

Les logs sont une partie très importante de l'exploitation des systèmes d'informations, car ils peuvent contenir des traces de l'utilisation (normale, comme malveillante) du système d'information (SI).

On trouve fréquemment des systèmes de logs sous forme de fichiers, de tables de BD, ou même sous forme d'évènements implantés dans les logiciels.

Au niveau de Kubernetes, le mode de remontée des logs le plus commun est l'écriture sur le STDOUT et le STDERR du processus qui tourne dans le pod. En complément, il est également être assez courant d'utiliser des sidecars pour effectuer des logs, par exemple pour récupérer le contenu de certains fichiers (équivalent à du `tail -f`, ou une utilisation de tubes (nommés)).

??? information "Autres mécanismes de log"
    Au niveau des systèmes, on constate également un autre mécanisme qui est utilisé sur des systèmes classiques : le syslog (`man 3 syslog`, fonction non système). Le syslog est non seulement disponible comme service réseau, mais il est également prévu via la `libc` que les appels aux fonctions `syslog` utilisent `/dev/log` comme socket Unix de destination. (En terme de services réseau, on pourrait également penser aux serveurs AAA, avec le troisième A pour Accounting (par exemple FreeRadius)).

??? information "Syslog et socket Unix"
    Attention : les sockets Unix disposent également des différents modes d'utilisation, notamment `SOCK_STREAM` et `SOCK_DGRAM`. Selon <https://www.syslog-ng.com/technical-documents/doc/syslog-ng-open-source-edition/3.38/administration-guide/31#TOPIC-2026236>, syslog aurait originellement utilisé le mode `SOCK_STREAM` et qu'à cause d'une attaque DOS ce mode aurait changé en `SOCK_DGRAM`. Lorsqu'on regarde différentes implémentations (notamment rsyslog, systemd, et syslog-ng), il semblerait que soit proposé par défaut l'utilisation de `SOCK_DGRAM`.

Il existe aussi des fonctions de syslog en tant qu'appels systèmes (`man 2 syslog`, appel système), qui lui s'occupe des logs générés par le kernel.

??? information "Télémétrie"
    En plus de ces éléments, il semblerait que les logs soient un constituant de la télémétrie. La télémétrie peut être intéressante, car elle est englobe un certain nombre de choses, que ce soit du traçage de code, via de l'instrumentation manuelle et/ou automatique, un traçage éventuellement distribué entre les systèmes (propagation d'un contexte), la remontée de métriques, et la remontée des logs. Ce système peut être intéressant dans le futur. Pour le moment, son intérêt semble toutefois limité, car Civiparoisse n'est pas encore une architecture ultra-complexe, et les interactions entre éléments ne sont pas encore trop nombreuses. Toutefois, c'est un sujet qu'il faudra surveiller de près, car il peut faciliter le travail des administrateurs puisque le traçage distribué pourrait devenir une sorte de clef de voute reliant les différents types d'information décrivant une même situation.
    
??? warning "FluentBit et Syslog Unix : les modes unix_udp et unix_tcp"
    Dans l'entrée syslog de FluentBit (<https://docs.fluentbit.io/manual/pipeline/inputs/syslog>), il faut comprendre le mode `unix_udp` comme une ouverture de socket en `AF_UNIX` et `SOCK_DGRAM`, tandis que le mode `unix_tcp` est une ouverture de socket en `AF_UNIX` et `SOCK_STREAM`.

??? warning "A réfléchir : logs comme un flux à parser ou un flux d'évènements"
    Lorsqu'on travaille avec des fichiers de logs, on cherche à déterminer des blocs de lignes qui vont ensemble, et qui constituent une entrée de log "atomique". En travaillant avec des flux d'évènements, il serait éventuellement possible d'obtenir cette granularité que l'on a au départ avec l'emploi des commandes générant les logs. Une idée serait de chercher à obtenir cette granularité via un log par syslog, mais syslog va être limité dans les tailles de messages à cause du moyen de transport - alors que les stack traces peuvent devenir lourdes...

## Au niveau de Civiparoisse

Au niveau de l'infrastructure Civiparoisse, on constate qu'il y a plusieurs sources de données de logs :

* les logiciels serveurs eux-mêmes : Apache, MySQL, Traefik, et PHP (pour le cron).
* les stacks logicielles : au niveau de Drupal, on retrouve une infrastructure de log où l'on peut plugger des sorties de logs ; au niveau de CiviCRM, on dispose de plusieurs possibilités qui coexistent, comme les logs en BD, et ce dans plusieurs tables (dont celle prévue spécialement pour les logs), mais également les logs vers des fichiers.
* on pourrait éventuellement considérer les données d'audit (base de log de CiviCRM) comme source, mais cette table renferme intrinsèquement des données d'utilisateurs, et ne semble pas aussi pertinente pour les logs d'administration utilisables au quotidien - bien qu'ils pourraient se révéler très précieux pour analyser des modifications de données.

Il est important également de pouvoir séparer les différentes sources de logs :

* les logs de BD (les différentes instances mysql)
* les logs HTTP (générateurs possibles : Apache et Traefik)
* les logs issus de PHP (traitement de requêtes Apache)
* les logs issus de PHP (traitement des tâches cron)

On constate donc que presque chaque pod sera une source de log, et contiendra des éléments spécifiques (sauf Apache, qui pourra également récupérer les logs PHP, du fait de l'utilisation du module PHP de Apache, et non pas de PHP-FPM).

### Apache

La solution la plus simple, et qui est en oeuvre, est de créer des liens : liens de `/var/log/apache2/error.log` vers `/dev/stderr` et `/var/log/apache2/access.log` vers `/dev/stdout` et `/var/log/apache2/other_vhosts_access.log`  vers `/dev/stdout`. Le `LogLevel` est sur `warn`, et il n'y a pas de directive `BufferedLogs`, dont la valeur par défaut est off.

Le nécessaire est donc fait.

Une autre approche serait de configurer ErrorLog, TransferLog, et ou GlobalLog vers `/dev/stderr` ou `/dev/stdout`.

### MySQL

MySQL dispose d'une configuration par défaut pour les logs d'erreur, qui envoie les logs erreurs et les warnings sur une cible qui sous linux est par défaut stderr. Les logs sont documentés : <https://dev.mysql.com/doc/refman/8.0/en/server-logs.html>

De toute manière, il faut être en mesure d'interpréter les messages récupérés via la configuration par défaut, car les erreurs qui peuvent arriver avant la prise en compte des configurations peuvent éventuellement être loggués via les mécanismes par défaut.

Valeurs par défaut :
```
 log_error                                      | stderr                                      |
| log_error_services                             | log_filter_internal; log_sink_internal      |
| log_error_suppression_list                     |                                             |
| log_error_verbosity                            | 2                                           |
| log_output                                     | FILE                                        |

```

MySQL dispose en plus de l'ErrorLog d'autres types de logs :

- GeneralQueryLog : peut à l'occasion être utile
- BinaryLog : éventuellement à désactiver
- RelayLog
- SlowQueryLog : peut être utile
- DDLLog : géré par les mécanismes internes de MySQL


Eventuels ajustements de configuration :

```
log_error_services='log_filter_internal; log_sink_internal'
log_output=FILE
log_error=stderr
log_error_verbosity=3
log_timestamps=UTC
general_log=0
long_query_time=2
slow_query_log=ON
slow_query_log_file=/dev/stdout



```

argument de ligne de commande : 

```
--skip-log-bin
```

### PHP

La plupart des valeurs de configuration relatives aux logs sont spécifiés dans le php.ini. Le seule paramètre qui n'est pas indiqué est le paramètre `error_log` - dans le cas présent, ces logs passeront donc par Apache pour sortir.

Dans le fichier de prod : 

```
error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT
display_errors = Off
display_startup_errors = Off
log_errors = On
log_errors_max_len = 1024
ignore_repeated_errors = Off
ignore_repeated_source = Off
report_memleaks = On
```

Eventuellement, on pourrait changer les valeurs suivantes :

```ini
log_errors_max_len = 0
error_log = /dev/stderr
error_reporting = E_ALL
```

### Drupal
Il existe plusieurs modules pour effectuer une sortie vers stdout ou stderr, dont en particulier le module `drupal/log_stdout`(<https://www.drupal.org/project/log_stdout>), que l'on peut configurer pour utiliser également stderr :

```bash
drush --no-interaction --root /app pm:enable log_stdout
drush --no-interaction --root /app config:set -n log_stdout.settings use_stderr 1
```


### CiviCRM
CiviCRM permet d'utiliser, pour la grande partie des messages, le loggueur issu du CMS. Du coup, la configuration de Drupal, et l'activation de l'utilisation du logger système devraient déjà avoir un impact significatif :

```bash
cv --cwd=/app setting:set userFrameworkLogging=1
```


### Cron CiviCRM
Il existe un certain nombre de logs complémentaires qui sont stockés via des objets, dont notamment `CRM_Core_Dao_JobLog`, `CRM_Core_Dao_SystemLog`. On pourra utiliser notamment le hook postSave, qui devrait pouvoir être utilisable du fait des DAO : <https://docs.civicrm.org/dev/en/latest/hooks/hook_civicrm_postSave_table_name/>


## Ce qui va réellement être mis en place

MYSQL : on va rester sur la verbosity 2, les `log_error_services` par défaut, le `log_error` par défaut. En revanche, on va activer `long_query_time=2` `slow_query_log=1` et `slow_query_log_file=/dev/stdout`

APACHE : on ne fait rien, puisque le nécessaire est déjà fait d'une certaine manière

PHP : on ne modifie rien : le `error_log` est par défaut, et le `log_errors_max_len` ne sert à rien en PHP 8.0 et est supprimé en PHP 8.1 selon <https://www.php.net/manual/en/errorfunc.configuration.php> ; en ce qui concerne les erreurs `E_DEPRECATED` concerne les fonctions qui seront supprimées dans les prochaines versions et `E_STRICT` serait des suggestions de modification de code, selon <https://www.php.net/manual/en/errorfunc.constants.php#constant.e-deprecated>.

DRUPAL : activation de `log_stdout` avec la configuration prévue

CIVICRM : activation du `userFrameworkLogging`

CRON Civicrm : dans l'extension, utiliser les postSave pour le JobLog et le SystemLog. En revanche, la documentation <https://docs.civicrm.org/dev/en/latest/hooks/hook_civicrm_postSave_table_name/> dit clairement qu'il faut faire attention à ne pas déclencher une boucle. Du coup, on va faire nous-même une sortie directe vers stdout ou stderr :

- JobLog : on envoie tout le JobLog sur stdout ; et en plus, si le JobLog comporte le mot clef Failure (vérification faite dans <https://github.com/civicrm/civicrm-core/blob/8cd192cbbb963444923f1dc0acb5185dc53f1e3e/CRM/Utils/Check/Component/Env.php#L795>), on envoie la ligne en plus dans stderr
- SystemLog : il y a un champ level qui utilise les niveaux PSR3 <https://www.php-fig.org/psr/psr-3/>. Si on a du notice, du info ou du debug, on l'envoie sur stdout ; sinon, on l'envoie sur stderr.

```php
    const EMERGENCY = 'emergency';
    const ALERT     = 'alert';
    const CRITICAL  = 'critical';
    const ERROR     = 'error';
    const WARNING   = 'warning';
    const NOTICE    = 'notice';
    const INFO      = 'info';
    const DEBUG     = 'debug';
```    
Ecrire sur stdout et stderr : voir <https://www.php.net/manual/en/wrappers.php.php>, <https://www.php.net/manual/en/reserved.constants.php#constant.stdout>, et surtout <https://www.php.net/manual/en/features.commandline.io-streams.php> ; en gros il faudra faire du fopen, du fwrite, du fflush et du fclose sur du php://stdout ou du php://stderr. On va mettre les éléments dans des classes avec singleton, et utiliser constructeur et destructeur pour ouvrir et fermer correctement les fichiers. Voir <https://www.php.net/manual/fr/language.oop5.decon.php>.
A noter que l'écriture sur les flux de php est ce qui a été implémenté dans le module drupal log_stdout.	