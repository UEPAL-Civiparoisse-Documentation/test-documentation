# Docker : build-push et séparation des opérations

Dans le contexte d'un tunnel d'intégration de Civiparoisse, l'idéal serait de créer un build "candidat", puis de le faire vérifier par le tunnel avant de le publier s'il a passé tout le tunnel.

Cela suppose donc que les actions de build d'une image et du push vers un repository soient deux opérations séparées et distinctes. Dans le cadre d'un workflow, on peut très bien builder à la main une image, et la pousser également manuellement par la suite (voir <https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#pushing-container-images>).

Néanmoins, la pratique répandue est d'utiliser des actions Github déjà existantes, en particulier celles que fournit Docker (<https://github.com/docker/build-push-action>). On pourrait se dire que le fait qu'on soit obligé de builder l'image lorsqu'on utilise cette action va être problématique, car on pousserait un code qui pourrait ne pas être le même que celui testé. Toutefois, c'est là que peut intervenir le cache : à Dockerfile et fichiers de contexte constants, Docker peut utiliser les layers qui ont déjà été compilés pour préparer une nouvelle image.  
Ceci signifie aussi que si on recompile une image, la compilation va être très rapide, puisque les caches pourront être réutilisés. La présence du cache n'est pas une garantie formelle que les layers seront réutilisés, mais présente une probabilité que l'on peut juger suffisante dans le cadre du projet Civiparoisse pour admettre qu'il y a de fortes chances que les layers seront réutilisés et que ce sera donc effectivement du code qui a validé le tunnel d'intégration qui va être poussé vers le registre d'images à la fin du traitement (voir <https://docs.docker.com/build/guide/layers/>, <https://docs.docker.com/build/cache/>, et la pratique des labels en début de Dockerfile, pour induire une petite modification qui va forcer à rebuilder la stack à partir de l'instruction LABEL).
